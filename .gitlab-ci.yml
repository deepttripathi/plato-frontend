# Define a variable for the image name and tag. This uses GitLab's predefined variables.
variables:
  IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  GITLAB_IMAGE_TAG: "creditonebank/it/infrastructure/platform-engineering/platform-automation-tool/plato-frontend"
  FULL_IMAGE_PATH: "${GITLAB_C1B_IMAGE_REGISTRY_PROD}/${GITLAB_IMAGE_TAG}:$CI_COMMIT_SHORT_SHA"

# Define the stages of the pipeline
stages:
  # - build_image
  - build_helm
  - deploy_dev
#  - deploy_prod

default:
  tags:
    - openshift
    - dv01
    - DV01

# build_image:
#   stage: build_image
#   image:
#     name: gcr.io/kaniko-project/executor:v1.9.0-debug
#     entrypoint:
#     - ''
#   services:
#     - docker:dind
#   before_script:
#     - echo "{\"auths\":{\"${GITLAB_C1B_IMAGE_REGISTRY_PROD}\":{\"auth\":\"$(printf "%s:%s" "${GITLAB_C1B_IMAGE_REGISTRY_USER}" "${GITLAB_C1B_IMAGE_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
#   script:
#     - /kaniko/executor --context ${CI_PROJECT_DIR} --dockerfile ${CI_PROJECT_DIR}/Dockerfile --destination ${GITLAB_C1B_IMAGE_REGISTRY_PROD}/${GITLAB_IMAGE_TAG}:$CI_COMMIT_SHORT_SHA  --ignore-path=/usr/bin/newuidmap --ignore-path=/usr/bin/newgidmap
#   rules:
#     # Run this job on every push, but not for tags
#     - if: '$CI_COMMIT_TAG == null'

build_helm:
  stage: build_helm
  image: alpine/helm:latest
  script:
    - cd $CI_PROJECT_DIR/deployment/plato-frontend
    - pwd
    - helm package ./
    - ls -ltr
    - TAR_BALL=$(ls | grep tgz)
    - helm push $TAR_BALL ${GITLAB_C1B_PACKAGE_REGISTRY_PROD}/${GITLAB_PACKAGE_TAG}:$CI_COMMIT_SHORT_SHA
  rules:
    # Run this job on every push, but not for tags
    - if: '$CI_COMMIT_TAG == null'

# Job to deploy to the 'development' environment
deploy_dev:
  #extends: .deploy_template
  image: alpine/helm:latest
  stage: deploy_dev
  variables:
    KUBE_URL: $DEV_KUBE_URL
    KUBE_TOKEN: $DEV_KUBE_TOKEN
    KUBE_NAMESPACE: $DEV_KUBE_NAMESPACE
    KUBE_CLUSTER: $DEV_KUBE_CLUSTER
    DEPLOYMENT_NAME: $DEV_DEPLOYMENT_NAME
    DEPLOYMENT_DIR: "deployment/$DEV_DEPLOYMENT_NAME"
  environment:
    name: development
  before_script:
    # Configure kubectl to connect to the target Kubernetes cluster
    - echo "Configuring kubectl for $CI_ENVIRONMENT_NAME environment..."
    # Install kubectl
    - apk add --no-cache curl
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    # Verify installation
    - kubectl version --client
  script:
    # Use 'kubectl set image' to trigger a rolling update with the new image.
    # Note: This assumes the container name inside your deployment spec is the same as the deployment name itself.
    - echo "Dev kube url $DEV_KUBE_URL"
    - echo "Deploying image $IMAGE_TAG to $DEPLOYMENT_NAME..."
    - echo "Namespace '$KUBE_NAMESPACE'"
    - echo "URL '$KUBE_URL'"
    #- export KUBE_CERT=$(kubectl get cm kube-root-ca.crt -o jsonpath="{['data']['ca\.crt']}" --server="${KUBE_URL}" --token="${KUBE_TOKEN}")
    #- echo $KUBE_CERT > ./ca.crt
    - kubectl get cm kube-root-ca.crt -o jsonpath="{['data']['ca\.crt']}" --server="${KUBE_URL}" --token="${KUBE_TOKEN}" --namespace="${KUBE_NAMESPACE}" --insecure-skip-tls-verify > ./ca.crt
    - >
      helm upgrade 
      --install "${DEPLOYMENT_NAME}" 
      --namespace "${KUBE_NAMESPACE}" 
      --set namespace="${KUBE_NAMESPACE}" 
      --set imageTagName="${GITLAB_IMAGE_TAG}" 
      --set envName="$CI_ENVIRONMENT" 
      --set deployName="${DEPLOYMENT_NAME}" 
      --set name="${CI_PROJECT_NAME}" 
      --set clusterName="${KUBE_CLUSTER}" 
      --kube-token "${KUBE_TOKEN}" 
      --set minReplicas="1" --set maxReplicas="2"
      --kube-apiserver "${KUBE_URL}" 
      --kube-ca-file ./ca.crt 
      --set image="${FULL_IMAGE_PATH}"
      ./${DEPLOYMENT_DIR}
  rules:
    # Run automatically on pushes to the 'main' branch
    - if: '$CI_COMMIT_BRANCH == "develop"'

# Job to deploy to the 'production' environment
# deploy_prod:
#   stage: deploy_prod
#   variables:
#     KUBE_URL: $PROD_KUBE_URL
#     KUBE_TOKEN: $PROD_KUBE_TOKEN
#     KUBE_NAMESPACE: $PROD_KUBE_NAMESPACE
#     DEPLOYMENT_NAME: $PROD_DEPLOYMENT_NAME
#   environment:
#     name: production
#   rules:
#     # This job must be triggered manually from the GitLab UI.
#     # It only becomes available after a successful push to the 'main' branch.
#     - if: '$CI_COMMIT_BRANCH == "main"'
#       when: manual
